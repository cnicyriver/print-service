// Generated by CoffeeScript 1.7.1
(function() {
  var async, checkingPrintList, checkingPrintLogList, cluster, curlify, db, getRanWorker, host, i, lastCheckingTime, moment, nconf, orm, paging, password, regMessage, restify, user, _i, _ref;

  cluster = require('cluster');

  orm = require('orm');

  moment = require('moment');

  nconf = require('./lib/nconf');

  restify = require('restify');

  curlify = require('request-as-curl');

  async = require('async');

  paging = require('./lib/paging');

  checkingPrintList = false;

  lastCheckingTime = null;

  checkingPrintLogList = false;

  if (cluster.isMaster) {
    regMessage = function(worker) {
      worker.on('message', function(msg) {
        if (msg === 'checkingPrintListComplete') {
          return checkingPrintList = false;
        }
        if (msg === 'checkingPrintLogListComplete') {
          return checkingPrintLogList = false;
        }
        return getRanWorker().send(msg);
      });
      return worker.on('listening', function(msg) {
        return checkingPrintList = false;
      });
    };
    getRanWorker = function() {
      var i, id, j, worker, _ref;
      i = j = 0;
      for (id in cluster.workers) {
        i++;
      }
      j = Math.floor(Math.random() * i);
      i = 0;
      _ref = cluster.workers;
      for (id in _ref) {
        worker = _ref[id];
        if (i === j) {
          return worker;
        }
        i++;
      }
    };
    if (nconf.get('print:autoCheckPrint')) {
      setInterval(function() {
        if (new Date() - lastCheckingTime > nconf.get('print:checkCrashTime')) {
          checkingPrintList = false;
        }
        if (checkingPrintList) {
          return;
        }
        checkingPrintList = true;
        lastCheckingTime = new Date();
        return getRanWorker().send('checkPrintStatus');
      }, 2000);
    }
    for (i = _i = 1, _ref = require('os').cpus().length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
      regMessage(cluster.fork());
    }
    cluster.on('exit', function(worker) {
      return regMessage(cluster.fork());
    });
    return;
  }

  user = nconf.get('mysql:user');

  password = nconf.get('mysql:password');

  host = nconf.get('mysql:host');

  db = nconf.get('mysql:db');

  orm.connect("mysql://" + user + ":" + password + "@" + host + "/" + db, function(err, db) {
    var server, serverParams;
    if (err) {
      console.log('Cannot connect to Mysql.');
      throw err;
    }
    db.settings.set('connection.debug', true);
    serverParams = {};
    server = restify.createServer(serverParams);
    server.use(restify.gzipResponse());
    server.use(restify.authorizationParser());
    server.use(restify.bodyParser({
      mapParams: false
    }));
    server.use(restify.queryParser());
    server.use(function(req, res, next) {
      req.db = db;
      req.models = db.models;
      return next();
    });
    server.use(restify.CORS());
    server.use(restify.fullResponse());
    server.use(paging.supportPagination);
    server.on('uncaughtException', function(req, res, route, error) {
      console.log('Uncaught exception in ' + route.method + ' ' + route.path + ':');
      console.log(error);
      return res.send('server error.');
    });
    server.listen(nconf.get('server:port'), function() {
      return console.log("" + server.name + " listening at " + server.url);
    });
    require('./models/print_log')(db);
    require('./models/print_manage')(db);
    require('./routes/service.print')(server);
    return process.on('message', function(msg) {
      switch (msg) {
        case 'checkPrintTask':
          return db.models.print_log.loopPrint(null, function() {
            return process.send('checkingPrintLogListComplete');
          });
        case 'checkPrintStatus':
          db.models.print_log.clearOld();
          db.models.print_log.checkTimeoutLogs();
          db.models.print_log.loopPrint();
          return db.models.print_manage.getOneEarlyChecked(function(err, print) {
            if (!print) {
              return process.send('checkingPrintListComplete');
            }
            return print.queryStatus(function(err, print) {
              if (print.print_status === 0) {
                return process.send('checkingPrintListComplete');
              } else {
                return db.models.print_log.loopFill(print.print_manage_id, function() {
                  return process.send('checkingPrintListComplete');
                });
              }
            });
          });
      }
    });
  });

}).call(this);
