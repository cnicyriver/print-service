// Generated by CoffeeScript 1.7.1
(function() {
  var CONST, Pos, async, cluster, moment, nconf, orm;

  Pos = require('../lib/pos');

  nconf = require('../lib/nconf');

  orm = require('orm');

  moment = require('moment');

  cluster = require('cluster');

  async = require('async');

  CONST = {
    waiting: 0,
    success: 1,
    fail: 2,
    error: 3,
    printing: 4,
    other: 5
  };

  module.exports = function(db) {
    var print_log;
    print_log = db.define('print_log', {
      print_log_id: {
        type: 'serial'
      },
      addtime: {
        type: 'integer',
        size: 11
      },
      printIP: {
        type: 'text'
      },
      print_message: {
        type: 'object'
      },
      is_ok: {
        type: 'integer'
      },
      success_no: {
        type: 'text'
      },
      print_type: {
        type: 'text'
      },
      print_time: {
        type: 'integer',
        size: 11
      },
      trans_id: {
        type: 'text'
      },
      print_nums: {
        type: 'integer',
        size: 11
      }
    }, {
      id: 'print_log_id',
      methods: {
        print: function(callback) {
          if (callback == null) {
            callback = function() {};
          }
          this.is_ok = this.printIP ? CONST.printing : CONST.other;
          this.print_time = new Date().getTime() / 1000;
          this.trans_id = null;
          return this.save((function(_this) {
            return function(err) {
              var beforeStauts, result;
              if (err || !_this.printIP) {
                return callback(err, _this);
              }
              result = Pos.print(_this.printIP, _this.print_message);
              beforeStauts = _this.is_ok;
              _this.is_ok = result === 0 ? CONST.success : CONST.fail;
              if (result === 'OpenError') {
                _this.is_ok = CONST.error;
              }
              _this.print_nums++;
              console.log(moment(new Date()).format('YYYYMMDDHHmmssSSS'), '进程id', cluster.worker.id, '日志id', _this.print_log_id, _this.is_ok, beforeStauts, _this.print_nums, result);
              return _this.save(function(err) {
                return callback(err, _this);
              });
            };
          })(this));
        }
      }
    });
    print_log.getOneByStatus = function(status, callback) {
      if (callback == null) {
        callback = function() {};
      }
      return this.one({
        is_ok: status
      }, callback);
    };
    print_log.getOneByPrintManage = function(print_manage_id, callback) {
      if (callback == null) {
        callback = function() {};
      }
      return this.one({
        print_id: print_manage_id
      }, callback);
    };
    print_log.loopFill = function(print_manage_id, callback) {
      if (callback == null) {
        callback = function() {};
      }
      return this.find({
        print_id: print_manage_id,
        is_ok: CONST.error
      }).each(function(print_log) {
        return print_log.is_ok = CONST.waiting;
      }).save((function(_this) {
        return function(err) {
          return _this.loopPrint(null, callback);
        };
      })(this));
    };
    print_log.loopPrint = function(trans_id, callback) {
      if (callback == null) {
        callback = function() {};
      }
      if (!trans_id) {
        trans_id = Math.random();
        db.models.print_log.find({
          is_ok: 0,
          trans_id: null
        }).each(function(print_log) {
          return print_log.trans_id = trans_id;
        }).save((function(_this) {
          return function(err) {
            return _this.loopPrint(trans_id, callback);
          };
        })(this));
        return;
      }
      return this.one({
        is_ok: CONST.waiting,
        trans_id: trans_id
      }, (function(_this) {
        return function(err, log) {
          if (err || !log) {
            return callback();
          }
          return log.print(function() {
            return _this.loopPrint(trans_id, callback);
          });
        };
      })(this));
    };
    print_log.clearOld = function(callback) {
      var clearTimes, lastTime;
      if (callback == null) {
        callback = function() {};
      }
      clearTimes = nconf.get('print:clearOldTimes');
      if (clearTimes === 0) {
        return callback();
      }
      lastTime = (new Date().getTime() - clearTimes) / 1000;
      return this.find({
        addtime: orm.lt(lastTime)
      }).remove(callback);
    };
    return print_log.checkTimeoutLogs = function(callback) {
      var lastTime, self, timeOut;
      if (callback == null) {
        callback = function() {};
      }
      timeOut = nconf.get('print:printTimeout');
      if (timeOut === 0) {
        return callback();
      }
      lastTime = (new Date().getTime() - timeOut) / 1000;
      self = this;
      return async.parallel({
        find: function(cb) {
          return self.find({
            print_time: orm.lt(lastTime),
            is_ok: CONST.printing
          }).each(function(log) {
            return log.is_ok = CONST.error;
          }).save(cb);
        },
        find1: function(cb) {
          return self.find({
            addtime: orm.lt(lastTime),
            is_ok: CONST.waiting
          }).each(function(log) {
            log.is_ok = CONST.waiting;
            return log.trans_id = null;
          }).save(cb);
        }
      }, function(err, result) {
        return callback();
      });
    };
  };

}).call(this);
